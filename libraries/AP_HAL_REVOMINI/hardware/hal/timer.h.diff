--- timer.h	2016-11-10 10:13:17.034356178 +0500
+++ timer.h.new	2016-11-10 10:15:57.146712702 +0500
@@ -35,75 +35,81 @@
 #ifndef _TIMERS_H_
 #define _TIMERS_H_
 
-#include "hal.h"
+#include "libmaple.h"
+#include "rcc.h"
+#include "nvic.h"
 #include "bitband.h"
 
+#ifdef __cplusplus
+extern "C"{
+#endif
+
 /*
  * Register maps and devices
  */
 
 /** Advanced control timer register map type */
 typedef struct timer_adv_reg_map {
-    __IO uint32_t CR1;            /**< Control register 1 */
-    __IO uint32_t CR2;            /**< Control register 2 */
-    __IO uint32_t SMCR;           /**< Slave mode control register */
-    __IO uint32_t DIER;           /**< DMA/Interrupt enable register */
-    __IO uint32_t SR;             /**< Status register */
-    __IO uint32_t EGR;            /**< Event generation register  */
-    __IO uint32_t CCMR1;          /**< Capture/compare mode register 1 */
-    __IO uint32_t CCMR2;          /**< Capture/compare mode register 2 */
-    __IO uint32_t CCER;           /**< Capture/compare enable register */
-    __IO uint32_t CNT;            /**< Counter */
-    __IO uint32_t PSC;            /**< Prescaler */
-    __IO uint32_t ARR;            /**< Auto-reload register */
-    __IO uint32_t RCR;            /**< Repetition counter register */
-    __IO uint32_t CCR1;           /**< Capture/compare register 1 */
-    __IO uint32_t CCR2;           /**< Capture/compare register 2 */
-    __IO uint32_t CCR3;           /**< Capture/compare register 3 */
-    __IO uint32_t CCR4;           /**< Capture/compare register 4 */
-    __IO uint32_t BDTR;           /**< Break and dead-time register */
-    __IO uint32_t DCR;            /**< DMA control register */
-    __IO uint32_t DMAR;           /**< DMA address for full transfer */
+    __io uint32 CR1;            /**< Control register 1 */
+    __io uint32 CR2;            /**< Control register 2 */
+    __io uint32 SMCR;           /**< Slave mode control register */
+    __io uint32 DIER;           /**< DMA/Interrupt enable register */
+    __io uint32 SR;             /**< Status register */
+    __io uint32 EGR;            /**< Event generation register  */
+    __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
+    __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
+    __io uint32 CCER;           /**< Capture/compare enable register */
+    __io uint32 CNT;            /**< Counter */
+    __io uint32 PSC;            /**< Prescaler */
+    __io uint32 ARR;            /**< Auto-reload register */
+    __io uint32 RCR;            /**< Repetition counter register */
+    __io uint32 CCR1;           /**< Capture/compare register 1 */
+    __io uint32 CCR2;           /**< Capture/compare register 2 */
+    __io uint32 CCR3;           /**< Capture/compare register 3 */
+    __io uint32 CCR4;           /**< Capture/compare register 4 */
+    __io uint32 BDTR;           /**< Break and dead-time register */
+    __io uint32 DCR;            /**< DMA control register */
+    __io uint32 DMAR;           /**< DMA address for full transfer */
 } timer_adv_reg_map;
 
 /** General purpose timer register map type */
 typedef struct timer_gen_reg_map {
-    __IO uint32_t CR1;            /**< Control register 1 */
-    __IO uint32_t CR2;            /**< Control register 2 */
-    __IO uint32_t SMCR;           /**< Slave mode control register */
-    __IO uint32_t DIER;           /**< DMA/Interrupt enable register */
-    __IO uint32_t SR;             /**< Status register */
-    __IO uint32_t EGR;            /**< Event generation register  */
-    __IO uint32_t CCMR1;          /**< Capture/compare mode register 1 */
-    __IO uint32_t CCMR2;          /**< Capture/compare mode register 2 */
-    __IO uint32_t CCER;           /**< Capture/compare enable register */
-    __IO uint32_t CNT;            /**< Counter */
-    __IO uint32_t PSC;            /**< Prescaler */
-    __IO uint32_t ARR;            /**< Auto-reload register */
-    const uint32_t RESERVED1;     /**< Reserved */
-    __IO uint32_t CCR1;           /**< Capture/compare register 1 */
-    __IO uint32_t CCR2;           /**< Capture/compare register 2 */
-    __IO uint32_t CCR3;           /**< Capture/compare register 3 */
-    __IO uint32_t CCR4;           /**< Capture/compare register 4 */
-    const uint32_t RESERVED2;     /**< Reserved */
-    __IO uint32_t DCR;            /**< DMA control register */
-    __IO uint32_t DMAR;           /**< DMA address for full transfer */
+    __io uint32 CR1;            /**< Control register 1 */
+    __io uint32 CR2;            /**< Control register 2 */
+    __io uint32 SMCR;           /**< Slave mode control register */
+    __io uint32 DIER;           /**< DMA/Interrupt enable register */
+    __io uint32 SR;             /**< Status register */
+    __io uint32 EGR;            /**< Event generation register  */
+    __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
+    __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
+    __io uint32 CCER;           /**< Capture/compare enable register */
+    __io uint32 CNT;            /**< Counter */
+    __io uint32 PSC;            /**< Prescaler */
+    __io uint32 ARR;            /**< Auto-reload register */
+    const uint32 RESERVED1;     /**< Reserved */
+    __io uint32 CCR1;           /**< Capture/compare register 1 */
+    __io uint32 CCR2;           /**< Capture/compare register 2 */
+    __io uint32 CCR3;           /**< Capture/compare register 3 */
+    __io uint32 CCR4;           /**< Capture/compare register 4 */
+    const uint32 RESERVED2;     /**< Reserved */
+    __io uint32 DCR;            /**< DMA control register */
+    __io uint32 DMAR;           /**< DMA address for full transfer */
 } timer_gen_reg_map;
 
 /** Basic timer register map type */
 typedef struct timer_bas_reg_map {
-    __IO uint32_t CR1;            /**< Control register 1 */
-    __IO uint32_t CR2;            /**< Control register 2 */
-    const uint32_t RESERVED1;     /**< Reserved */
-    __IO uint32_t DIER;           /**< DMA/Interrupt enable register */
-    __IO uint32_t SR;             /**< Status register */
-    __IO uint32_t EGR;            /**< Event generation register  */
-    const uint32_t RESERVED2;     /**< Reserved */
-    const uint32_t RESERVED3;     /**< Reserved */
-    const uint32_t RESERVED4;     /**< Reserved */
-    __IO uint32_t CNT;            /**< Counter */
-    __IO uint32_t PSC;            /**< Prescaler */
-    __IO uint32_t ARR;            /**< Auto-reload register */
+    __io uint32 CR1;            /**< Control register 1 */
+    __io uint32 CR2;            /**< Control register 2 */
+    const uint32 RESERVED1;     /**< Reserved */
+    __io uint32 DIER;           /**< DMA/Interrupt enable register */
+    __io uint32 SR;             /**< Status register */
+    __io uint32 EGR;            /**< Event generation register  */
+    const uint32 RESERVED2;     /**< Reserved */
+    const uint32 RESERVED3;     /**< Reserved */
+    const uint32 RESERVED4;     /**< Reserved */
+    __io uint32 CNT;            /**< Counter */
+    __io uint32 PSC;            /**< Prescaler */
+    __io uint32 ARR;            /**< Auto-reload register */
 } timer_bas_reg_map;
 
 
@@ -168,22 +174,22 @@
 
 /** Timer device type */
 typedef struct timer_dev {
-    TIM_TypeDef *regs;
-    uint32_t clk;
+    timer_reg_map regs;         /**< Register map */
+    rcc_clk_id clk_id;          /**< RCC clock information */
     timer_type type;            /**< Timer's type */
-    uint16_t af;                // GPIO AF number
-    voidFuncPtr *handlers;     /**< User IRQ handlers */
+    voidFuncPtr handlers[];     /**< User IRQ handlers */
 } timer_dev;
 
-
-
-void TIM2_IRQHandler(void);
-void TIM3_IRQHandler(void);
-void TIM4_IRQHandler(void);
-void TIM5_IRQHandler(void);
-void TIM6_IRQHandler(void);
-void TIM7_IRQHandler(void);
-void TIM8_IRQHandler(void);
+extern timer_dev *TIMER1;
+extern timer_dev *TIMER2;
+extern timer_dev *TIMER3;
+extern timer_dev *TIMER4;
+#ifdef STM32_HIGH_DENSITY
+extern timer_dev *TIMER5;
+extern timer_dev *TIMER6;
+extern timer_dev *TIMER7;
+extern timer_dev *TIMER8;
+#endif
 
 /*
  * Register bit definitions
@@ -547,36 +553,6 @@
     TIMER_CH4 = 4  /**< Channel 4 */
 } timer_channel;
 
-
-#ifdef __cplusplus
-#define CONSTEXPR constexpr
-  extern "C" {
-#else
-#define CONSTEXPR
-#endif
-
-
-extern const timer_dev timer1;
-extern const timer_dev timer2;
-extern const timer_dev timer3;
-extern const timer_dev timer4;
-extern const timer_dev timer5;
-extern const timer_dev timer6;
-extern const timer_dev timer7;
-extern const timer_dev timer8;
-extern const timer_dev timer12;
-
-
-extern  const timer_dev * const TIMER1;
-extern  const timer_dev * const TIMER2;
-extern  const timer_dev * const TIMER3;
-extern  const timer_dev * const TIMER4;
-extern  const timer_dev * const TIMER5;
-extern  const timer_dev * const TIMER6;
-extern  const timer_dev * const TIMER7;
-extern  const timer_dev * const TIMER8;
-extern  const timer_dev * const TIMER12;
-
 /*
  * Note: Don't require timer_channel arguments! We want to be able to say
  *
@@ -587,11 +563,10 @@
  * without the compiler yelling at us.
  */
 
-void timer_init(const timer_dev *dev);
-void timer_reset(const timer_dev *dev);
-void timer_disable(const timer_dev *dev);
-void timer_set_mode(const timer_dev *dev, uint8_t channel, timer_mode mode);
-void timer_foreach(void (*fn)(const timer_dev*));
+void timer_init(timer_dev *dev);
+void timer_disable(timer_dev *dev);
+void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode);
+void timer_foreach(void (*fn)(timer_dev*));
 
 /**
  * @brief Timer interrupt number.
@@ -615,10 +590,10 @@
     TIMER_BREAK_INTERRUPT /**< Break interrupt, advanced timers only. */
 } timer_interrupt_id;
 
-void timer_attach_interrupt(const timer_dev *dev,
-                            uint8_t interrupt,
+void timer_attach_interrupt(timer_dev *dev,
+                            uint8 interrupt,
                             voidFuncPtr handler);
-void timer_detach_interrupt(const timer_dev *dev, uint8_t interrupt);
+void timer_detach_interrupt(timer_dev *dev, uint8 interrupt);
 
 /**
  * Initialize all timer devices on the chip.
@@ -641,8 +616,8 @@
  *
  * @param dev Device whose counter to pause.
  */
-static inline void timer_pause(const timer_dev *dev) {
-    *bb_perip(&(dev->regs)->CR1, TIMER_CR1_CEN_BIT) = 0;
+static inline void timer_pause(timer_dev *dev) {
+    *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 0;
 }
 
 /**
@@ -652,8 +627,8 @@
  *
  * @param dev Device whose counter to resume
  */
-static inline void timer_resume(const timer_dev *dev) {
-    *bb_perip(&(dev->regs)->CR1, TIMER_CR1_CEN_BIT) = 1;
+static inline void timer_resume(timer_dev *dev) {
+    *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 1;
 }
 
 /**
@@ -664,8 +639,8 @@
  *
  * @param dev Timer whose counter to return
  */
-static inline uint16_t timer_get_count(const timer_dev *dev) {
-    return (uint16_t)(dev->regs)->CNT;
+static inline uint16 timer_get_count(timer_dev *dev) {
+    return (uint16)(dev->regs).bas->CNT;
 }
 
 /**
@@ -673,8 +648,8 @@
  * @param dev Timer whose counter to set
  * @param value New counter value
  */
-static inline void timer_set_count(const timer_dev *dev, uint16_t value) {
-    (dev->regs)->CNT = value;
+static inline void timer_set_count(timer_dev *dev, uint16 value) {
+    (dev->regs).bas->CNT = value;
 }
 
 /**
@@ -689,8 +664,8 @@
  * @param dev Timer whose prescaler to return
  * @see timer_generate_update()
  */
-static inline uint16_t timer_get_prescaler(const timer_dev *dev) {
-    return (uint16_t)(dev->regs)->PSC;
+static inline uint16 timer_get_prescaler(timer_dev *dev) {
+    return (uint16)(dev->regs).bas->PSC;
 }
 
 /**
@@ -703,16 +678,16 @@
  * @param psc New prescaler value
  * @see timer_generate_update()
  */
-static inline void timer_set_prescaler(const timer_dev *dev, uint16_t psc) {
-    (dev->regs)->PSC = psc;
+static inline void timer_set_prescaler(timer_dev *dev, uint16 psc) {
+    (dev->regs).bas->PSC = psc;
 }
 
 /**
  * @brief Returns a timer's reload value.
  * @param dev Timer whose reload value to return
  */
-static inline uint16_t timer_get_reload(const timer_dev *dev) {
-    return (uint16_t)(dev->regs)->ARR;
+static inline uint16 timer_get_reload(timer_dev *dev) {
+    return (uint16)(dev->regs).bas->ARR;
 }
 
 /**
@@ -721,8 +696,8 @@
  * @param arr New reload value to use.  Takes effect at next update event.
  * @see timer_generate_update()
  */
-static inline void timer_set_reload(const timer_dev *dev, uint16_t arr) {
-    (dev->regs)->ARR = arr;
+static inline void timer_set_reload(timer_dev *dev, uint16 arr) {
+    (dev->regs).bas->ARR = arr;
 }
 
 /**
@@ -730,8 +705,8 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
  * @param channel Channel whose compare value to get.
  */
-static inline uint16_t timer_get_compare(const timer_dev *dev, uint8_t channel) {
-    __IO uint32_t *ccr = &(dev->regs)->CCR1 + (channel - 1);
+static inline uint16 timer_get_compare(timer_dev *dev, uint8 channel) {
+    __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
     return *ccr;
 }
 
@@ -741,10 +716,10 @@
  * @param channel Channel whose compare value to set.
  * @param value   New compare value.
  */
-static inline void timer_set_compare(const timer_dev *dev,
-                                     uint8_t channel,
-                                     uint16_t value) {
-    __IO uint32_t *ccr = &(dev->regs)->CCR1 + (channel - 1);
+static inline void timer_set_compare(timer_dev *dev,
+                                     uint8 channel,
+                                     uint16 value) {
+    __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
     *ccr = value;
 }
 
@@ -758,24 +733,24 @@
  *
  * @param dev Timer device to generate an update for.
  */
-static inline void timer_generate_update(const timer_dev *dev) {
-    *bb_perip(&(dev->regs)->EGR, TIMER_EGR_UG_BIT) = 1;
+static inline void timer_generate_update(timer_dev *dev) {
+    *bb_perip(&(dev->regs).bas->EGR, TIMER_EGR_UG_BIT) = 1;
 }
 
 /**
  * @brief Enable a timer's trigger DMA request
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL
  */
-static inline void timer_dma_enable_trg_req(const timer_dev *dev) {
-    *bb_perip(&(dev->regs)->DIER, TIMER_DIER_TDE_BIT) = 1;
+static inline void timer_dma_enable_trg_req(timer_dev *dev) {
+    *bb_perip(&(dev->regs).gen->DIER, TIMER_DIER_TDE_BIT) = 1;
 }
 
 /**
  * @brief Disable a timer's trigger DMA request
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL
  */
-static inline void timer_dma_disable_trg_req(const timer_dev *dev) {
-    *bb_perip(&(dev->regs)->DIER, TIMER_DIER_TDE_BIT) = 0;
+static inline void timer_dma_disable_trg_req(timer_dev *dev) {
+    *bb_perip(&(dev->regs).gen->DIER, TIMER_DIER_TDE_BIT) = 0;
 }
 
 /**
@@ -783,8 +758,8 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL
  * @param channel Channel whose DMA request to enable.
  */
-static inline void timer_dma_enable_req(const timer_dev *dev, uint8_t channel) {
-    *bb_perip(&(dev->regs)->DIER, channel + 8) = 1;
+static inline void timer_dma_enable_req(timer_dev *dev, uint8 channel) {
+    *bb_perip(&(dev->regs).gen->DIER, channel + 8) = 1;
 }
 
 /**
@@ -792,8 +767,8 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
  * @param channel Channel whose DMA request to disable.
  */
-static inline void timer_dma_disable_req(const timer_dev *dev, uint8_t channel) {
-    *bb_perip(&(dev->regs)->DIER, channel + 8) = 0;
+static inline void timer_dma_disable_req(timer_dev *dev, uint8 channel) {
+    *bb_perip(&(dev->regs).gen->DIER, channel + 8) = 0;
 }
 
 /**
@@ -804,37 +779,8 @@
  * @see timer_interrupt_id
  * @see timer_channel
  */
-static inline void timer_enable_irq(const timer_dev *dev, uint8_t interrupt) {
-//    *bb_perip(&(dev->regs)->DIER, interrupt) = 1;
-	switch(interrupt)
-	{
-	case TIMER_UPDATE_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_Update, ENABLE);
-	    break;		
-	case TIMER_CC1_INTERRUPT: 
-	    TIM_ITConfig(dev->regs, TIM_IT_CC1, ENABLE);
-	    break;		
-	case TIMER_CC2_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_CC2, ENABLE);
-	    break;		
-	case TIMER_CC3_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_CC3, ENABLE);
-	    break;		
-	case TIMER_CC4_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_CC4, ENABLE);
-	    break;		
-	case TIMER_COM_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_COM, ENABLE);
-	    break;		
-	case TIMER_TRG_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_Trigger, ENABLE);
-            break;		
-	case TIMER_BREAK_INTERRUPT:
-	    TIM_ITConfig(dev->regs, TIM_IT_Break, ENABLE);
-	    break;
-	}
-	
-	
+static inline void timer_enable_irq(timer_dev *dev, uint8 interrupt) {
+    *bb_perip(&(dev->regs).adv->DIER, interrupt) = 1;
 }
 
 /**
@@ -845,35 +791,8 @@
  * @see timer_interrupt_id
  * @see timer_channel
  */
-static inline void timer_disable_irq(const timer_dev *dev, uint8_t interrupt) {
- //   *bb_perip(&(dev->regs)->DIER, interrupt) = 0;
-	switch(interrupt)
-	{
-		case TIMER_UPDATE_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_Update, DISABLE);
-						break;		
-		case TIMER_CC1_INTERRUPT: 
-						TIM_ITConfig(dev->regs, TIM_IT_CC1, DISABLE);
-						break;		
-		case TIMER_CC2_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_CC2, DISABLE);
-						break;		
-		case TIMER_CC3_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_CC3, DISABLE);
-						break;		
-		case TIMER_CC4_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_CC4, DISABLE);
-						break;		
-		case TIMER_COM_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_COM, DISABLE);
-						break;		
-		case TIMER_TRG_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_Trigger, DISABLE);
-						break;		
-		case TIMER_BREAK_INTERRUPT:
-						TIM_ITConfig(dev->regs, TIM_IT_Break, DISABLE);
-						break;
-	} 
+static inline void timer_disable_irq(timer_dev *dev, uint8 interrupt) {
+    *bb_perip(&(dev->regs).adv->DIER, interrupt) = 0;
 }
 
 /**
@@ -887,25 +806,8 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
  * @param channel Channel to enable, from 1 to 4.
  */
-static inline void timer_cc_enable(const timer_dev *dev, uint8_t channel) {
-    //*bb_perip(&(dev->regs)->CCER, 4 * (channel - 1)) = 1;
-    switch(channel)
-    {
-		case 1:
-				dev->regs->CCER |= (uint16_t)TIM_CCER_CC1E;		
-				break;
-		case 2:
-				dev->regs->CCER |= (uint16_t)TIM_CCER_CC2E;
-				break;
-		case 3:
-				dev->regs->CCER |= (uint16_t)TIM_CCER_CC3E;
-				break;
-		case 4:
-				dev->regs->CCER |= (uint16_t)TIM_CCER_CC4E;
-				break;
-		default:
-				break;
-	}    
+static inline void timer_cc_enable(timer_dev *dev, uint8 channel) {
+    *bb_perip(&(dev->regs).gen->CCER, 4 * (channel - 1)) = 1;
 }
 
 /**
@@ -914,25 +816,8 @@
  * @param channel Channel to disable, from 1 to 4.
  * @see timer_cc_enable()
  */
-static inline void timer_cc_disable(const timer_dev *dev, uint8_t channel) {
-    //*bb_perip(&(dev->regs)->CCER, 4 * (channel - 1)) = 0;
-    switch(channel)
-    {
-		case 1:
-				dev->regs->CCER &= (uint16_t)~TIM_CCER_CC1E;		
-				break;
-		case 2:
-				dev->regs->CCER &= (uint16_t)~TIM_CCER_CC2E;
-				break;
-		case 3:
-				dev->regs->CCER &= (uint16_t)~TIM_CCER_CC3E;
-				break;
-		case 4:
-				dev->regs->CCER &= (uint16_t)~TIM_CCER_CC4E;
-				break;
-		default:
-				break;
-	}
+static inline void timer_cc_disable(timer_dev *dev, uint8 channel) {
+    *bb_perip(&(dev->regs).gen->CCER, 4 * (channel - 1)) = 0;
 }
 
 /**
@@ -942,8 +827,8 @@
  * @return Polarity, either 0 or 1.
  * @see timer_cc_set_polarity()
  */
-static inline uint8_t timer_cc_get_pol(const timer_dev *dev, uint8_t channel) {
-    return *bb_perip(&(dev->regs)->CCER, 4 * (channel - 1) + 1);
+static inline uint8 timer_cc_get_pol(timer_dev *dev, uint8 channel) {
+    return *bb_perip(&(dev->regs).gen->CCER, 4 * (channel - 1) + 1);
 }
 
 /**
@@ -963,8 +848,8 @@
  * @param channel Channel whose capture/compare output polarity to set.
  * @param pol New polarity, 0 or 1.
  */
-static inline void timer_cc_set_pol(const timer_dev *dev, uint8_t channel, uint8_t pol) {
-    *bb_perip(&(dev->regs)->CCER, 4 * (channel - 1) + 1) = pol;
+static inline void timer_cc_set_pol(timer_dev *dev, uint8 channel, uint8 pol) {
+    *bb_perip(&(dev->regs).gen->CCER, 4 * (channel - 1) + 1) = pol;
 }
 
 /**
@@ -972,8 +857,8 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
  * @return Number of bytes to be transferred per DMA request, from 1 to 18.
  */
-static inline uint8_t timer_dma_get_burst_len(const timer_dev *dev) {
-    uint32_t dbl = ((dev->regs)->DCR & TIMER_DCR_DBL) >> 8;
+static inline uint8 timer_dma_get_burst_len(timer_dev *dev) {
+    uint32 dbl = ((dev->regs).gen->DCR & TIMER_DCR_DBL) >> 8;
     return dbl + 1;             /* 0 means 1 byte, etc. */
 }
 
@@ -983,11 +868,11 @@
  * @param length DMA burst length; i.e., number of bytes to transfer
  *               per DMA request, from 1 to 18.
  */
-static inline void timer_dma_set_burst_len(const timer_dev *dev, uint8_t length) {
-    uint32_t tmp = (dev->regs)->DCR;
+static inline void timer_dma_set_burst_len(timer_dev *dev, uint8 length) {
+    uint32 tmp = (dev->regs).gen->DCR;
     tmp &= ~TIMER_DCR_DBL;
     tmp |= (length - 1) << 8;
-    (dev->regs)->DCR = tmp;
+    (dev->regs).gen->DCR = tmp;
 }
 
 /**
@@ -1041,8 +926,8 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
  * @return DMA base address
  */
-static inline timer_dma_base_addr timer_dma_get_base_addr(const timer_dev *dev) {
-    uint32_t dcr = (dev->regs)->DCR;
+static inline timer_dma_base_addr timer_dma_get_base_addr(timer_dev *dev) {
+    uint32 dcr = (dev->regs).gen->DCR;
     return (timer_dma_base_addr)(dcr & TIMER_DCR_DBA);
 }
 
@@ -1054,15 +939,14 @@
  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
  * @param dma_base DMA base address.
  */
-static inline void timer_dma_set_base_addr(const timer_dev *dev,
+static inline void timer_dma_set_base_addr(timer_dev *dev,
                                            timer_dma_base_addr dma_base) {
-    uint32_t tmp = (dev->regs)->DCR;
+    uint32 tmp = (dev->regs).gen->DCR;
     tmp &= ~TIMER_DCR_DBA;
     tmp |= dma_base;
-    (dev->regs)->DCR = tmp;
+    (dev->regs).gen->DCR = tmp;
 }
 
-
 /**
  * Timer output compare modes.
  */
@@ -1066,7 +950,6 @@
 /**
  * Timer output compare modes.
  */
-#if 0
 typedef enum timer_oc_mode {
     TIMER_OC_MODE_FROZEN = 0 << 4, /**< Frozen: comparison between output
                                       compare register and counter has no
@@ -1109,7 +991,6 @@
     TIMER_OC_PE = BIT(3),       /**< Output compare preload enable. */
     TIMER_OC_FE = BIT(2)        /**< Output compare fast enable. */
 } timer_oc_mode_flags;
-#endif
 
 /**
  * @brief Configure a channel's output compare mode.
@@ -1126,6 +1007,7 @@
                                      timer_oc_mode mode,
                                      uint8 flags) {
     uint8 bit0 = channel & 1;
+    //uint8 bit1 = (channel >> 1) & 1;  // original
     uint8 bit1 = ((channel-1) >> 1) & 1;  // fixed
     /* channel == 1,2 -> CCMR1; channel == 3,4 -> CCMR2 */
     __io uint32 *ccmr = &(dev->regs).gen->CCMR1 + bit1;
@@ -1138,24 +1020,8 @@
     *ccmr = tmp;
 }
 
-/*
-TIMER_OC_MODE_ACTIVE_ON_MATCH   	TIM_OCMode_Active
-TIMER_OC_MODE_INACTIVE_ON_MATCH 	TIM_OCMode_Inactive
-TIMER_OC_MODE_TOGGLE				TIM_OCMode_Toggle
-TIMER_OC_MODE_PWM_1					TIM_OCMode_PWM1
-TIMER_OC_MODE_PWM_2					TIM_OCMode_PWM2
-
-TIMER_OC_FE 						TIM_OCFast_Enable		TIM_OC1FastConfig
-TIMER_OC_PE							TIM_OCPreload_Enable 	TIM_OC1PreloadConfig
-TIMER_OC_CE							TIM_OCClear_Enable		TIM_ClearOC1Ref
-
-
-Note2: In case of PWM mode, this function is mandatory:
-00646               TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
-					
-*/
 #ifdef __cplusplus
-  }
+} // extern "C"
 #endif
 
 #endif
