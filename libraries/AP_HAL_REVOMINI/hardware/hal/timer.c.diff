--- timer.c	2016-11-10 10:15:12.902614184 +0500
+++ timer.c.new	2016-11-10 10:16:10.975743496 +0500
@@ -31,8 +31,6 @@
  */
 
 #include "timer.h"
-#include <string.h>
-
 
 /* Just like the corresponding DIER bits:
  * [0] = Update handler;
@@ -46,156 +44,97 @@
 /* Update only. */
 #define NR_BAS_HANDLERS                 1
 
-
-voidFuncPtr tim1_handlers[NR_ADV_HANDLERS]= {0};
-const timer_dev timer1 = {
-    .regs         = TIM1,
-    .clk	  = RCC_APB2Periph_TIM1,
+static timer_dev timer1 = {
+    .regs         = { .adv = TIMER1_BASE },
+    .clk_id       = RCC_TIMER1,
     .type         = TIMER_ADVANCED,
-    .af           = GPIO_AF_TIM1,
-    .handlers     = tim1_handlers,
+    .handlers     = { [NR_ADV_HANDLERS - 1] = 0 },
 };
 /** Timer 1 device (advanced) */
+timer_dev *TIMER1 = &timer1;
 
-voidFuncPtr tim2_handlers[NR_GEN_HANDLERS]={0};
-const timer_dev timer2 = {
-    .regs         = TIM2,
-    .clk    	  = RCC_APB1Periph_TIM2,
+static timer_dev timer2 = {
+    .regs         = { .gen = TIMER2_BASE },
+    .clk_id       = RCC_TIMER2,
     .type         = TIMER_GENERAL,
-    .af           = GPIO_AF_TIM2,
-    .handlers     = tim2_handlers,
+    .handlers     = { [NR_GEN_HANDLERS - 1] = 0 },
 };
 /** Timer 2 device (general-purpose) */
+timer_dev *TIMER2 = &timer2;
 
-voidFuncPtr tim3_handlers[NR_GEN_HANDLERS]={0};
-const timer_dev timer3 = {
-    .regs         = TIM3,
-    .clk	  = RCC_APB1Periph_TIM3,
+static timer_dev timer3 = {
+    .regs         = { .gen = TIMER3_BASE },
+    .clk_id       = RCC_TIMER3,
     .type         = TIMER_GENERAL,
-    .af           = GPIO_AF_TIM3,
-    .handlers     = tim3_handlers,
+    .handlers     = { [NR_GEN_HANDLERS - 1] = 0 },
 };
 /** Timer 3 device (general-purpose) */
+timer_dev *TIMER3 = &timer3;
 
-voidFuncPtr tim4_handlers[NR_GEN_HANDLERS]={0};
-const timer_dev timer4 = {
-    .regs         = TIM4,
-    .clk       	  = RCC_APB1Periph_TIM4,
+static timer_dev timer4 = {
+    .regs         = { .gen = TIMER4_BASE },
+    .clk_id       = RCC_TIMER4,
     .type         = TIMER_GENERAL,
-    .af           = GPIO_AF_TIM4,
-    .handlers     = tim4_handlers,
+    .handlers     = { [NR_GEN_HANDLERS - 1] = 0 },
 };
 /** Timer 4 device (general-purpose) */
+timer_dev *TIMER4 = &timer4;
 
-voidFuncPtr tim5_handlers[NR_GEN_HANDLERS]={0};
-const timer_dev timer5 = {
-    .regs         = TIM5,
-    .clk          = RCC_APB1Periph_TIM5,
+#ifdef STM32_HIGH_DENSITY
+static timer_dev timer5 = {
+    .regs         = { .gen = TIMER5_BASE },
+    .clk_id       = RCC_TIMER5,
     .type         = TIMER_GENERAL,
-    .af           = GPIO_AF_TIM5,
-    .handlers     = tim5_handlers,
+    .handlers     = { [NR_GEN_HANDLERS - 1] = 0 },
 };
 /** Timer 5 device (general-purpose) */
+timer_dev *TIMER5 = &timer5;
 
-voidFuncPtr tim6_handlers[NR_BAS_HANDLERS]={0};
-const timer_dev timer6 = {
-    .regs         = TIM6,
-    .clk          = RCC_APB1Periph_TIM6,
+static timer_dev timer6 = {
+    .regs         = { .bas = TIMER6_BASE },
+    .clk_id       = RCC_TIMER6,
     .type         = TIMER_BASIC,
-    .af           = 0,
-    .handlers     = tim6_handlers,
+    .handlers     = { [NR_BAS_HANDLERS - 1] = 0 },
 };
 /** Timer 6 device (basic) */
+timer_dev *TIMER6 = &timer6;
 
-voidFuncPtr tim7_handlers[NR_BAS_HANDLERS]={0};
-const timer_dev timer7 = {
-    .regs         = TIM7,
-    .clk          = RCC_APB1Periph_TIM7,
+static timer_dev timer7 = {
+    .regs         = { .bas = TIMER7_BASE },
+    .clk_id       = RCC_TIMER7,
     .type         = TIMER_BASIC,
-    .af           = 0,
-    .handlers     = tim7_handlers,
+    .handlers     = { [NR_BAS_HANDLERS - 1] = 0 },
 };
 /** Timer 7 device (basic) */
+timer_dev *TIMER7 = &timer7;
 
-voidFuncPtr tim8_handlers[NR_ADV_HANDLERS]={0};
-const timer_dev timer8 = {
-    .regs         = TIM8,
-    .clk          = RCC_APB2Periph_TIM8,
+static timer_dev timer8 = {
+    .regs         = { .adv = TIMER8_BASE },
+    .clk_id       = RCC_TIMER8,
     .type         = TIMER_ADVANCED,
-    .af           = GPIO_AF_TIM8,
-    .handlers     = tim8_handlers,
+    .handlers     = { [NR_ADV_HANDLERS - 1] = 0 },
 };
 /** Timer 8 device (advanced) */
-
-voidFuncPtr tim12_handlers[NR_GEN_HANDLERS]={0};
-const timer_dev timer12 = {
-    .regs         = TIM12,
-    .clk          = RCC_APB1Periph_TIM12,
-    .type         = TIMER_GENERAL,
-    .af           = GPIO_AF_TIM12,
-    .handlers     = tim12_handlers,
-};
-/** Timer 12 device (general-purpose) */
-
-
-
-const timer_dev * const TIMER1 = &timer1;
-const timer_dev * const TIMER2 = &timer2;
-const timer_dev * const TIMER3 = &timer3;
-const timer_dev * const TIMER4 = &timer4;
-const timer_dev * const TIMER5 = &timer5;
-const timer_dev * const TIMER6 = &timer6;
-const timer_dev * const TIMER7 = &timer7;
-const timer_dev * const TIMER8 = &timer8;
-const timer_dev * const TIMER12 = &timer12;
-
+timer_dev *TIMER8 = &timer8;
+#endif
 
 /*
  * Convenience routines
  */
 
-static void disable_channel(const timer_dev *dev, uint8_t channel);
-static void pwm_mode(const timer_dev *dev, uint8_t channel);
-static void output_compare_mode(const timer_dev *dev, uint8_t channel);
-
-static inline void enable_irq(const timer_dev *dev, uint8_t interrupt);
+static void disable_channel(timer_dev *dev, uint8 channel);
+static void pwm_mode(timer_dev *dev, uint8 channel);
+static void output_compare_mode(timer_dev *dev, uint8 channel);
 
-/**
- * Initialize a timer (enable timer clock)
- * @param dev Timer to initialize
- */
-void timer_init(const timer_dev *dev) {
-	if (dev->regs == TIM1 || dev->regs == TIM8 || dev->regs == TIM9 || dev->regs == TIM10 || dev->regs == TIM11)
-		RCC_APB2PeriphClockCmd(dev->clk, ENABLE);
-	else
-		RCC_APB1PeriphClockCmd(dev->clk, ENABLE);
-}
+static inline void enable_irq(timer_dev *dev, uint8 interrupt);
 
 /**
  * Initialize a timer, and reset its register map.
  * @param dev Timer to initialize
  */
-void timer_reset(const timer_dev *dev) {
-    switch (dev->type) {
-    case TIMER_ADVANCED:
-	memset(dev->handlers, 0, NR_ADV_HANDLERS * sizeof(voidFuncPtr));
-	break;
-	
-    case TIMER_GENERAL:
-	memset(dev->handlers, 0, NR_ADV_HANDLERS * sizeof(voidFuncPtr));
-	break;
-	
-    case TIMER_BASIC:
-	memset(dev->handlers, 0, NR_BAS_HANDLERS * sizeof(voidFuncPtr));
-	break;
-    }
-
-    if (dev->regs == TIM1 || dev->regs == TIM8 || dev->regs == TIM9 || dev->regs == TIM10 || dev->regs == TIM11)
-	RCC_APB2PeriphClockCmd(dev->clk, ENABLE);
-    else
-	RCC_APB1PeriphClockCmd(dev->clk, ENABLE);
-    TIM_DeInit(dev->regs);
-
+void timer_init(timer_dev *dev) {
+    rcc_clk_enable(dev->clk_id);
+    rcc_reset_dev(dev->clk_id);
 }
 
 /**
@@ -206,13 +145,13 @@
  *
  * @param dev Timer to disable.
  */
-void timer_disable(const timer_dev *dev) {
-    dev->regs->CR1 = 0;
-    dev->regs->DIER = 0;
+void timer_disable(timer_dev *dev) {
+    (dev->regs).bas->CR1 = 0;
+    (dev->regs).bas->DIER = 0;
     switch (dev->type) {
     case TIMER_ADVANCED:        /* fall-through */
     case TIMER_GENERAL:
-        (dev->regs)->CCER = 0;
+        (dev->regs).gen->CCER = 0;
         break;
     case TIMER_BASIC:
         break;
@@ -230,11 +169,11 @@
  * @param channel Relevant channel
  * @param mode New timer mode for channel
  */
-void timer_set_mode(const timer_dev *dev, uint8_t channel, timer_mode mode) {
-    assert_param(channel > 0 && channel <= 4);
+void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode) {
+    ASSERT_FAULT(channel > 0 && channel <= 4);
 
     /* TODO decide about the basic timers */
-    assert_param(dev->type != TIMER_BASIC);
+    ASSERT(dev->type != TIMER_BASIC);
     if (dev->type == TIMER_BASIC)
         return;
 
@@ -255,15 +194,17 @@
  * @brief Call a function on timer devices.
  * @param fn Function to call on each timer device.
  */
-void timer_foreach(void (*fn)(const timer_dev*)) {
-    //fn(TIMER1);
+void timer_foreach(void (*fn)(timer_dev*)) {
+    fn(TIMER1);
     fn(TIMER2);
     fn(TIMER3);
     fn(TIMER4);
-    //fn(TIMER5);
-    //fn(TIMER6);
+#ifdef STM32_HIGH_DENSITY
+    fn(TIMER5);
+    fn(TIMER6);
     fn(TIMER7);
-    //fn(TIMER8);
+    fn(TIMER8);
+#endif
 }
 
 /**
@@ -276,8 +217,8 @@
  * @see timer_interrupt_id
  * @see timer_channel
  */
-void timer_attach_interrupt(const timer_dev *dev,
-                            uint8_t interrupt,
+void timer_attach_interrupt(timer_dev *dev,
+                            uint8 interrupt,
                             voidFuncPtr handler) {
     dev->handlers[interrupt] = handler;
     timer_enable_irq(dev, interrupt);
@@ -293,7 +234,7 @@
  * @see timer_interrupt_id
  * @see timer_channel
  */
-void timer_detach_interrupt(const timer_dev *dev, uint8_t interrupt) {
+void timer_detach_interrupt(timer_dev *dev, uint8 interrupt) {
     timer_disable_irq(dev, interrupt);
     dev->handlers[interrupt] = NULL;
 }
@@ -302,72 +243,71 @@
  * IRQ handlers
  */
 
-static inline void dispatch_adv_brk(const timer_dev *dev);
-static inline void dispatch_adv_up(const timer_dev *dev);
-static inline void dispatch_adv_trg_com(const timer_dev *dev);
-static inline void dispatch_adv_cc(const timer_dev *dev);
-static inline void dispatch_general(const timer_dev *dev);
-static inline void dispatch_basic(const timer_dev *dev);
-/*
-void TIM1_BRK_TIM9_IRQHandler(void)
-{
+static inline void dispatch_adv_brk(timer_dev *dev);
+static inline void dispatch_adv_up(timer_dev *dev);
+static inline void dispatch_adv_trg_com(timer_dev *dev);
+static inline void dispatch_adv_cc(timer_dev *dev);
+static inline void dispatch_general(timer_dev *dev);
+static inline void dispatch_basic(timer_dev *dev);
+
+void __irq_tim1_brk(void) {
     dispatch_adv_brk(TIMER1);
 }
 
-void TIM1_UP_TIM10_IRQHandler(void) {
+void __irq_tim1_up(void) {
     dispatch_adv_up(TIMER1);
 }
 
-void TIM1_TRG_COM_TIM11_IRQHandler(void) {
+void __irq_tim1_trg_com(void) {
     dispatch_adv_trg_com(TIMER1);
 }
 
-void TIM1_CC_IRQHandler(void) {
+void __irq_tim1_cc(void) {
     dispatch_adv_cc(TIMER1);
 }
-*/
-void TIM2_IRQHandler(void) {
+
+void __irq_tim2(void) {
     dispatch_general(TIMER2);
 }
 
-void TIM3_IRQHandler(void) {
+void __irq_tim3(void) {
     dispatch_general(TIMER3);
 }
 
-void TIM4_IRQHandler(void) {
+void __irq_tim4(void) {
     dispatch_general(TIMER4);
 }
-/*
-void TIM5_IRQHandler(void) {
+
+#if defined(STM32_HIGH_DENSITY) || defined(STM32_XL_DENSITY)
+
+void __irq_tim5(void) {
     dispatch_general(TIMER5);
 }
 
-void TIM6_DAC_IRQHandler(void) {
+void __irq_tim6(void) {
     dispatch_basic(TIMER6);
 }
-*/
-void TIM7_IRQHandler(void) {
+
+void __irq_tim7(void) {
     dispatch_basic(TIMER7);
 }
-/* used in PWM
-void TIM8_BRK_TIM12_IRQHandler(void) { // used in PWM tim12
-    dispatch_adv_brk(TIMER8);
-}
 
-void TIM8_CC_IRQHandler(void) { // used in PWM tim8
-    dispatch_adv_cc(TIMER8);
+void __irq_tim8_brk(void) {
+    dispatch_adv_brk(TIMER8);
 }
-*/
 
-void TIM8_UP_TIM13_IRQHandler(void) { // not conflicts with PWM
+void __irq_tim8_up(void) {
     dispatch_adv_up(TIMER8);
 }
 
-void TIM8_TRG_COM_TIM14_IRQHandler(void) {
+void __irq_tim8_trg_com(void) {
     dispatch_adv_trg_com(TIMER8);
 }
 
-          
+void __irq_tim8_cc(void) {
+    dispatch_adv_cc(TIMER8);
+}
+#endif
   
 /* Note: the following dispatch routines make use of the fact that
  * DIER interrupt enable bits and SR interrupt flags have common bit
@@ -378,22 +318,18 @@
 /* A special-case dispatch routine for single-interrupt NVIC lines.
  * This function assumes that the interrupt corresponding to `iid' has
  * in fact occurred (i.e., it doesn't check DIER & SR). */
-static inline void dispatch_single_irq(const timer_dev *dev,
+static inline void dispatch_single_irq(timer_dev *dev,
                                        timer_interrupt_id iid,
-                                       uint32_t irq_mask) {
-
-    if (dev->regs->DIER & dev->regs->SR & irq_mask) {
+                                       uint32 irq_mask) {
+    timer_bas_reg_map *regs = (dev->regs).bas;
         void (*handler)(void) = dev->handlers[iid];
         if (handler) {
             handler();
-            //dev->regs->SR &= ~irq_mask; 
-        }
-        dev->regs->SR &= ~irq_mask;  // reset IRQ inspite of installed handler! @NG
+        regs->SR &= ~irq_mask;
     }
 }
 
 /* For dispatch routines which service multiple interrupts. */
-/*
 #define handle_irq(dier_sr, irq_mask, handlers, iid, handled_irq) do {  \
         if ((dier_sr) & (irq_mask)) {                                   \
             void (*__handler)(void) = (handlers)[iid];                  \
@@ -403,30 +339,20 @@
             }                                                           \
         }                                                               \
     } while (0)
-*/
-
-static inline void handle_irq(uint32_t dier_sr, uint32_t irq_mask, void (**handlers)(void), uint32_t iid, uint32_t handled_irq) {
-    if ((dier_sr) & (irq_mask)) {                                 
-        void (*handler)(void) = (handlers)[iid];                
-        if (handler) {                                          
-            handler();                                          
-        }
-        handled_irq |= (irq_mask);   // reset IRQ inspite of installed handler! @NG
-    }
-}
 
-static inline void dispatch_adv_brk(const timer_dev *dev) {
+static inline void dispatch_adv_brk(timer_dev *dev) {
     dispatch_single_irq(dev, TIMER_BREAK_INTERRUPT, TIMER_SR_BIF);
 }
 
-static inline void dispatch_adv_up(const timer_dev *dev) {
+static inline void dispatch_adv_up(timer_dev *dev) {
     dispatch_single_irq(dev, TIMER_UPDATE_INTERRUPT, TIMER_SR_UIF);
 }
 
-static inline void dispatch_adv_trg_com(const timer_dev *dev) {
-    uint32_t dsr = dev->regs->DIER & dev->regs->SR;
+static inline void dispatch_adv_trg_com(timer_dev *dev) {
+    timer_adv_reg_map *regs = (dev->regs).adv;
+    uint32 dsr = regs->DIER & regs->SR;
     void (**hs)(void) = dev->handlers;
-    uint32_t handled = 0; /* Logical OR of SR interrupt flags we end up
+    uint32 handled = 0; /* Logical OR of SR interrupt flags we end up
                          * handling.  We clear these.  User handlers
                          * must clear overcapture flags, to avoid
                          * wasting time in output mode. */
@@ -434,30 +360,28 @@
     handle_irq(dsr, TIMER_SR_TIF,   hs, TIMER_TRG_INTERRUPT, handled);
     handle_irq(dsr, TIMER_SR_COMIF, hs, TIMER_COM_INTERRUPT, handled);
 
-    dev->regs->SR &= ~handled;
+    regs->SR &= ~handled;
 }
 
-static inline void dispatch_adv_cc(const timer_dev *dev) {
-    uint32_t dsr = dev->regs->DIER & dev->regs->SR;
+static inline void dispatch_adv_cc(timer_dev *dev) {
+    timer_adv_reg_map *regs = (dev->regs).adv;
+    uint32 dsr = regs->DIER & regs->SR;
     void (**hs)(void) = dev->handlers;
-    uint32_t handled = 0;
+    uint32 handled = 0;
 
     handle_irq(dsr, TIMER_SR_CC4IF, hs, TIMER_CC4_INTERRUPT, handled);
     handle_irq(dsr, TIMER_SR_CC3IF, hs, TIMER_CC3_INTERRUPT, handled);
     handle_irq(dsr, TIMER_SR_CC2IF, hs, TIMER_CC2_INTERRUPT, handled);
     handle_irq(dsr, TIMER_SR_CC1IF, hs, TIMER_CC1_INTERRUPT, handled);
 
-    dev->regs->SR &= ~handled;
+    regs->SR &= ~handled;
 }
 
-static inline void dispatch_general(const timer_dev *dev) {
-#ifdef ISR_PERF
-    uint32_t t=systick_micros();
-#endif
-
-    uint32_t dsr = dev->regs->DIER & dev->regs->SR;
+static inline void dispatch_general(timer_dev *dev) {
+    timer_gen_reg_map *regs = (dev->regs).gen;
+    uint32 dsr = regs->DIER & regs->SR;
     void (**hs)(void) = dev->handlers;
-    uint32_t handled = 0;
+    uint32 handled = 0;
 
     handle_irq(dsr, TIMER_SR_TIF,   hs, TIMER_TRG_INTERRUPT,    handled);
     handle_irq(dsr, TIMER_SR_CC4IF, hs, TIMER_CC4_INTERRUPT,    handled);
@@ -466,16 +390,10 @@
     handle_irq(dsr, TIMER_SR_CC1IF, hs, TIMER_CC1_INTERRUPT,    handled);
     handle_irq(dsr, TIMER_SR_UIF,   hs, TIMER_UPDATE_INTERRUPT, handled);
 
-    dev->regs->SR &= ~handled;
-
-#ifdef ISR_PERF
-    isr_time += systick_micros() - t;
-#endif
-
+    regs->SR &= ~handled;
 }
 
-// don't count time of basic timer because it used only as timer scheduler's interrupt
-static inline void dispatch_basic(const timer_dev *dev) {
+static inline void dispatch_basic(timer_dev *dev) {
     dispatch_single_irq(dev, TIMER_UPDATE_INTERRUPT, TIMER_SR_UIF);
 }
 
@@ -483,46 +401,26 @@
  * Utilities
  */
 
-static void disable_channel(const timer_dev *dev, uint8_t channel) {
+static void disable_channel(timer_dev *dev, uint8 channel) {
     timer_detach_interrupt(dev, channel);
     timer_cc_disable(dev, channel);
 }
 
-static void pwm_mode(const timer_dev *dev, uint8_t channel) {
+static void pwm_mode(timer_dev *dev, uint8 channel) {
     timer_disable_irq(dev, channel);
     timer_oc_set_mode(dev, channel, TIMER_OC_MODE_PWM_1, TIMER_OC_PE);
-/*
-    switch (channel)  {
-    case 1:
-	TIM_SelectOCxM(dev->regs, TIM_Channel_1, TIM_OCMode_PWM1);
-	TIM_OC1PreloadConfig(dev->regs, TIM_OCPreload_Enable);		
-	break;
-    case 2:
-	TIM_SelectOCxM(dev->regs, TIM_Channel_2, TIM_OCMode_PWM1);
-	TIM_OC2PreloadConfig(dev->regs, TIM_OCPreload_Enable);					
-	break;
-    case 3:
-	TIM_SelectOCxM(dev->regs, TIM_Channel_3, TIM_OCMode_PWM1);
-	TIM_OC3PreloadConfig(dev->regs, TIM_OCPreload_Enable);					
-	break;
-    case 4:
-	TIM_SelectOCxM(dev->regs, TIM_Channel_4, TIM_OCMode_PWM1);
-	TIM_OC4PreloadConfig(dev->regs, TIM_OCPreload_Enable);					
-	break;
-    }
-*/    
     timer_cc_enable(dev, channel);
 }
 
-static void output_compare_mode(const timer_dev *dev, uint8_t channel) {
+static void output_compare_mode(timer_dev *dev, uint8 channel) {
     timer_oc_set_mode(dev, channel, TIMER_OC_MODE_ACTIVE_ON_MATCH, 0);
     timer_cc_enable(dev, channel);
 }
 
-static void enable_advanced_irq(const timer_dev *dev, timer_interrupt_id id);
-static void enable_nonmuxed_irq(const timer_dev *dev);
+static void enable_advanced_irq(timer_dev *dev, timer_interrupt_id id);
+static void enable_nonmuxed_irq(timer_dev *dev);
 
-static inline void enable_irq(const timer_dev *dev, timer_interrupt_id iid) {
+static inline void enable_irq(timer_dev *dev, timer_interrupt_id iid) {
     if (dev->type == TIMER_ADVANCED) {
         enable_advanced_irq(dev, iid);
     } else {
@@ -530,38 +428,53 @@
     }
 }
 
-static void enable_advanced_irq(const timer_dev *dev, timer_interrupt_id id) {
-    uint8_t is_timer1 = dev->clk == RCC_APB2Periph_TIM1;
+static void enable_advanced_irq(timer_dev *dev, timer_interrupt_id id) {
+    uint8 is_timer1 = dev->clk_id == RCC_TIMER1;
 
     switch (id) {
     case TIMER_UPDATE_INTERRUPT:
-        NVIC_EnableIRQ(is_timer1 ? TIM1_UP_TIM10_IRQn : TIM8_UP_TIM13_IRQn);
+        nvic_irq_enable(is_timer1 ? NVIC_TIMER1_UP : NVIC_TIMER8_UP);
         break;
     case TIMER_CC1_INTERRUPT:
     case TIMER_CC2_INTERRUPT:
     case TIMER_CC3_INTERRUPT:
     case TIMER_CC4_INTERRUPT:
-        NVIC_EnableIRQ(is_timer1 ? TIM1_CC_IRQn : TIM8_CC_IRQn);
+        nvic_irq_enable(is_timer1 ? NVIC_TIMER1_CC : NVIC_TIMER8_CC);
         break;
     case TIMER_COM_INTERRUPT:
     case TIMER_TRG_INTERRUPT:
-        NVIC_EnableIRQ(is_timer1 ? TIM1_TRG_COM_TIM11_IRQn : TIM8_TRG_COM_TIM14_IRQn);
+        nvic_irq_enable(is_timer1 ? NVIC_TIMER1_TRG_COM : NVIC_TIMER8_TRG_COM);
         break;
     case TIMER_BREAK_INTERRUPT:
-        NVIC_EnableIRQ(is_timer1 ? TIM1_BRK_TIM9_IRQn : TIM8_BRK_TIM12_IRQn);
+        nvic_irq_enable(is_timer1 ? NVIC_TIMER1_BRK : NVIC_TIMER8_BRK);
         break;
     }
 }
 
-static void enable_nonmuxed_irq(const timer_dev *dev) {
-	if (dev->regs == TIM2)      NVIC_EnableIRQ(TIM2_IRQn);
-	else if (dev->regs == TIM3) NVIC_EnableIRQ(TIM3_IRQn);
-	else if (dev->regs == TIM4) NVIC_EnableIRQ(TIM4_IRQn);
-	else if (dev->regs == TIM5) NVIC_EnableIRQ(TIM5_IRQn);
-	else if (dev->regs == TIM6) NVIC_EnableIRQ(TIM6_DAC_IRQn);
-	else if (dev->regs == TIM7) NVIC_EnableIRQ(TIM7_IRQn);
-	else
-	{
-        assert_param(0);
+static void enable_nonmuxed_irq(timer_dev *dev) {
+    switch (dev->clk_id) {
+    case RCC_TIMER2:
+        nvic_irq_enable(NVIC_TIMER2);
+        break;
+    case RCC_TIMER3:
+        nvic_irq_enable(NVIC_TIMER3);
+        break;
+    case RCC_TIMER4:
+        nvic_irq_enable(NVIC_TIMER4);
+        break;
+#ifdef STM32_HIGH_DENSITY
+    case RCC_TIMER5:
+        nvic_irq_enable(NVIC_TIMER5);
+        break;
+    case RCC_TIMER6:
+        nvic_irq_enable(NVIC_TIMER6);
+        break;
+    case RCC_TIMER7:
+        nvic_irq_enable(NVIC_TIMER7);
+        break;
+#endif
+    default:
+        ASSERT_FAULT(0);
+        break;
     }
 }
